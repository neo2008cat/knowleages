
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>HashMap · GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../">
            
                <a href="../../">
            
                    
                    笔记本简介
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../introduce.html">
            
                <a href="../introduce.html">
            
                    
                    源码阅读
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../architecture.html">
            
                <a href="../architecture.html">
            
                    
                    JDK源码
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1.1" >
            
                <span>
            
                    
                    java.util
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter active" data-level="1.2.1.1.1" data-path="HashMap.html">
            
                <a href="HashMap.html">
            
                    
                    HashMap
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.2.1.2" >
            
                <span>
            
                    
                    java.util.concurrent
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1.2.1" data-path="../javautilconcurrent/CountDownLatch.html">
            
                <a href="../javautilconcurrent/CountDownLatch.html">
            
                    
                    CountDownLatch
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.2.2" data-path="../javautilconcurrent/CyclicBarrier.html">
            
                <a href="../javautilconcurrent/CyclicBarrier.html">
            
                    
                    CyclicBarrier
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../../technical_mind/introduce.html">
            
                <a href="../../technical_mind/introduce.html">
            
                    
                    技术心得
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../../technical_mind/java8.html">
            
                <a href="../../technical_mind/java8.html">
            
                    
                    Java8新特性
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../../technical_mind/g1_collector.html">
            
                <a href="../../technical_mind/g1_collector.html">
            
                    
                    G1收集器
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="../../technical_mind/tcp_ip.html">
            
                <a href="../../technical_mind/tcp_ip.html">
            
                    
                    Tcp/Ip协议详解
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="../../technical_mind/https.html">
            
                <a href="../../technical_mind/https.html">
            
                    
                    Https协议详解
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="../../technical_mind/websocket.html">
            
                <a href="../../technical_mind/websocket.html">
            
                    
                    WebSocket协议详解
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../../new_tech/introduce.html">
            
                <a href="../../new_tech/introduce.html">
            
                    
                    行业技术
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../../new_tech/docker.html">
            
                <a href="../../new_tech/docker.html">
            
                    
                    Docker
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../../new_tech/devops.html">
            
                <a href="../../new_tech/devops.html">
            
                    
                    DevOps
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="../../new_tech/kafka.html">
            
                <a href="../../new_tech/kafka.html">
            
                    
                    Kafka
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="../../new_tech/redis.html">
            
                <a href="../../new_tech/redis.html">
            
                    
                    Redis
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.5" data-path="../../new_tech/zookeeper.html">
            
                <a href="../../new_tech/zookeeper.html">
            
                    
                    Zookeeper
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.6" data-path="../../new_tech/elasticsearch.html">
            
                <a href="../../new_tech/elasticsearch.html">
            
                    
                    ElasticSearch
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.7" data-path="../../new_tech/spark.html">
            
                <a href="../../new_tech/spark.html">
            
                    
                    Spark
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.8" data-path="../../new_tech/storm.html">
            
                <a href="../../new_tech/storm.html">
            
                    
                    Storm
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../../tech_article/introdcue.html">
            
                <a href="../../tech_article/introdcue.html">
            
                    
                    技术文章
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="../../tech_article/devops_k8s_docker.html">
            
                <a href="../../tech_article/devops_k8s_docker.html">
            
                    
                    基于DevOps、微服务以及k8s的高可用架构探索与实现
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../../interview/introduce.html">
            
                <a href="../../interview/introduce.html">
            
                    
                    面试相关
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="../../interview/java.html">
            
                <a href="../../interview/java.html">
            
                    
                    Java基础
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="../../interview/project.html">
            
                <a href="../../interview/project.html">
            
                    
                    项目经验
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="../../interview/architecture.html">
            
                <a href="../../interview/architecture.html">
            
                    
                    系统架构
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.4" data-path="../../interview/optimize.html">
            
                <a href="../../interview/optimize.html">
            
                    
                    系统调优
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../.." >HashMap</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h2 id="hashmap&#x7684;&#x8282;&#x70B9;&#x6570;&#x636E;&#x7ED3;&#x6784;">HashMap&#x7684;&#x8282;&#x70B9;&#x6570;&#x636E;&#x7ED3;&#x6784;</h2>
<pre><code>        static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
            final int hash;
            final K key;
            V value;
            Node&lt;K,V&gt; next;

            Node(int hash, K key, V value, Node&lt;K,V&gt; next) {
                this.hash = hash;
                this.key = key;
                this.value = value;
                this.next = next;
            }

            public final K getKey()        { return key; }
            public final V getValue()      { return value; }
            public final String toString() { return key + &quot;=&quot; + value; }

            public final int hashCode() {
                return Objects.hashCode(key) ^ Objects.hashCode(value);
            }

            public final V setValue(V newValue) {
                V oldValue = value;
                value = newValue;
                return oldValue;
            }

            public final boolean equals(Object o) {
                if (o == this)
                    return true;
                if (o instanceof Map.Entry) {
                    Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;
                    if (Objects.equals(key, e.getKey()) &amp;&amp;
                        Objects.equals(value, e.getValue()))
                        return true;
                }
                return false;
            }
        }
</code></pre><blockquote>
<p>HashMap&#x51E0;&#x4E2A;&#x91CD;&#x8981;&#x5E38;&#x91CF;<br>    DEFAULT_INITIAL_CAPACITY<br>    MAXIMUM_CAPACITY<br>    DEFAULT_LOAD_FACTOR<br>    TREEIFY_THRESHOLD<br>    UNTREEIFY_THRESHOLD<br>    MIN_TREEIFY_CAPACITY  </p>
<p>Java 8&#x4E2D;&#x7684;&#x6563;&#x5217;&#x503C;&#x4F18;&#x5316;&#x51FD;&#x6570;
  &#x6270;&#x52A8;&#x51FD;&#x6570;</p>
</blockquote>
<pre><code>            static final int hash(Object key) {
                int h;
                return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
            }
</code></pre><blockquote>
<p>JDK8 HashMap&#x7EA2;&#x9ED1;&#x6811;</p>
</blockquote>
<pre><code>        static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; {
            TreeNode&lt;K,V&gt; parent;  // red-black tree links
            TreeNode&lt;K,V&gt; left;
            TreeNode&lt;K,V&gt; right;
            TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion
            boolean red;
            TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) {
                super(hash, key, val, next);
            }

            /**
             * Returns root of tree containing this node.
             */
            final TreeNode&lt;K,V&gt; root() {
                for (TreeNode&lt;K,V&gt; r = this, p;;) {
                    if ((p = r.parent) == null)
                        return r;
                    r = p;
                }
            }

            /**
             * Ensures that the given root is the first node of its bin.
             */
            static &lt;K,V&gt; void moveRootToFront(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root) {
                int n;
                if (root != null &amp;&amp; tab != null &amp;&amp; (n = tab.length) &gt; 0) {
                    int index = (n - 1) &amp; root.hash;
                    TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];
                    if (root != first) {
                        Node&lt;K,V&gt; rn;
                        tab[index] = root;
                        TreeNode&lt;K,V&gt; rp = root.prev;
                        if ((rn = root.next) != null)
                            ((TreeNode&lt;K,V&gt;)rn).prev = rp;
                        if (rp != null)
                            rp.next = rn;
                        if (first != null)
                            first.prev = root;
                        root.next = first;
                        root.prev = null;
                    }
                    assert checkInvariants(root);
                }
            }

            /**
             * Finds the node starting at root p with the given hash and key.
             * The kc argument caches comparableClassFor(key) upon first use
             * comparing keys.
             */
            final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) {
                TreeNode&lt;K,V&gt; p = this;
                do {
                    int ph, dir; K pk;
                    TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;
                    if ((ph = p.hash) &gt; h)
                        p = pl;
                    else if (ph &lt; h)
                        p = pr;
                    else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk)))
                        return p;
                    else if (pl == null)
                        p = pr;
                    else if (pr == null)
                        p = pl;
                    else if ((kc != null ||
                              (kc = comparableClassFor(k)) != null) &amp;&amp;
                             (dir = compareComparables(kc, k, pk)) != 0)
                        p = (dir &lt; 0) ? pl : pr;
                    else if ((q = pr.find(h, k, kc)) != null)
                        return q;
                    else
                        p = pl;
                } while (p != null);
                return null;
            }

            /**
             * Calls find for root node.
             */
            final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) {
                return ((parent != null) ? root() : this).find(h, k, null);
            }

            /**
             * Tie-breaking utility for ordering insertions when equal
             * hashCodes and non-comparable. We don&apos;t require a total
             * order, just a consistent insertion rule to maintain
             * equivalence across rebalancings. Tie-breaking further than
             * necessary simplifies testing a bit.
             */
            static int tieBreakOrder(Object a, Object b) {
                int d;
                if (a == null || b == null ||
                    (d = a.getClass().getName().
                     compareTo(b.getClass().getName())) == 0)
                    d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?
                         -1 : 1);
                return d;
            }

            /**
             * Forms tree of the nodes linked from this node.
             * @return root of tree
             */
            final void treeify(Node&lt;K,V&gt;[] tab) {
                TreeNode&lt;K,V&gt; root = null;
                for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) {
                    next = (TreeNode&lt;K,V&gt;)x.next;
                    x.left = x.right = null;
                    if (root == null) {
                        x.parent = null;
                        x.red = false;
                        root = x;
                    }
                    else {
                        K k = x.key;
                        int h = x.hash;
                        Class&lt;?&gt; kc = null;
                        for (TreeNode&lt;K,V&gt; p = root;;) {
                            int dir, ph;
                            K pk = p.key;
                            if ((ph = p.hash) &gt; h)
                                dir = -1;
                            else if (ph &lt; h)
                                dir = 1;
                            else if ((kc == null &amp;&amp;
                                      (kc = comparableClassFor(k)) == null) ||
                                     (dir = compareComparables(kc, k, pk)) == 0)
                                dir = tieBreakOrder(k, pk);

                            TreeNode&lt;K,V&gt; xp = p;
                            if ((p = (dir &lt;= 0) ? p.left : p.right) == null) {
                                x.parent = xp;
                                if (dir &lt;= 0)
                                    xp.left = x;
                                else
                                    xp.right = x;
                                root = balanceInsertion(root, x);
                                break;
                            }
                        }
                    }
                }
                moveRootToFront(tab, root);
            }

            /**
             * Returns a list of non-TreeNodes replacing those linked from
             * this node.
             */
            final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) {
                Node&lt;K,V&gt; hd = null, tl = null;
                for (Node&lt;K,V&gt; q = this; q != null; q = q.next) {
                    Node&lt;K,V&gt; p = map.replacementNode(q, null);
                    if (tl == null)
                        hd = p;
                    else
                        tl.next = p;
                    tl = p;
                }
                return hd;
            }

            /**
             * Tree version of putVal.
             */
            final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,
                                           int h, K k, V v) {
                Class&lt;?&gt; kc = null;
                boolean searched = false;
                TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this;
                for (TreeNode&lt;K,V&gt; p = root;;) {
                    int dir, ph; K pk;
                    if ((ph = p.hash) &gt; h)
                        dir = -1;
                    else if (ph &lt; h)
                        dir = 1;
                    else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk)))
                        return p;
                    else if ((kc == null &amp;&amp;
                              (kc = comparableClassFor(k)) == null) ||
                             (dir = compareComparables(kc, k, pk)) == 0) {
                        if (!searched) {
                            TreeNode&lt;K,V&gt; q, ch;
                            searched = true;
                            if (((ch = p.left) != null &amp;&amp;
                                 (q = ch.find(h, k, kc)) != null) ||
                                ((ch = p.right) != null &amp;&amp;
                                 (q = ch.find(h, k, kc)) != null))
                                return q;
                        }
                        dir = tieBreakOrder(k, pk);
                    }

                    TreeNode&lt;K,V&gt; xp = p;
                    if ((p = (dir &lt;= 0) ? p.left : p.right) == null) {
                        Node&lt;K,V&gt; xpn = xp.next;
                        TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);
                        if (dir &lt;= 0)
                            xp.left = x;
                        else
                            xp.right = x;
                        xp.next = x;
                        x.parent = x.prev = xp;
                        if (xpn != null)
                            ((TreeNode&lt;K,V&gt;)xpn).prev = x;
                        moveRootToFront(tab, balanceInsertion(root, x));
                        return null;
                    }
                }
            }

            /**
             * Removes the given node, that must be present before this call.
             * This is messier than typical red-black deletion code because we
             * cannot swap the contents of an interior node with a leaf
             * successor that is pinned by &quot;next&quot; pointers that are accessible
             * independently during traversal. So instead we swap the tree
             * linkages. If the current tree appears to have too few nodes,
             * the bin is converted back to a plain bin. (The test triggers
             * somewhere between 2 and 6 nodes, depending on tree structure).
             */
            final void removeTreeNode(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,
                                      boolean movable) {
                int n;
                if (tab == null || (n = tab.length) == 0)
                    return;
                int index = (n - 1) &amp; hash;
                TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;
                TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;
                if (pred == null)
                    tab[index] = first = succ;
                else
                    pred.next = succ;
                if (succ != null)
                    succ.prev = pred;
                if (first == null)
                    return;
                if (root.parent != null)
                    root = root.root();
                if (root == null || root.right == null ||
                    (rl = root.left) == null || rl.left == null) {
                    tab[index] = first.untreeify(map);  // too small
                    return;
                }
                TreeNode&lt;K,V&gt; p = this, pl = left, pr = right, replacement;
                if (pl != null &amp;&amp; pr != null) {
                    TreeNode&lt;K,V&gt; s = pr, sl;
                    while ((sl = s.left) != null) // find successor
                        s = sl;
                    boolean c = s.red; s.red = p.red; p.red = c; // swap colors
                    TreeNode&lt;K,V&gt; sr = s.right;
                    TreeNode&lt;K,V&gt; pp = p.parent;
                    if (s == pr) { // p was s&apos;s direct parent
                        p.parent = s;
                        s.right = p;
                    }
                    else {
                        TreeNode&lt;K,V&gt; sp = s.parent;
                        if ((p.parent = sp) != null) {
                            if (s == sp.left)
                                sp.left = p;
                            else
                                sp.right = p;
                        }
                        if ((s.right = pr) != null)
                            pr.parent = s;
                    }
                    p.left = null;
                    if ((p.right = sr) != null)
                        sr.parent = p;
                    if ((s.left = pl) != null)
                        pl.parent = s;
                    if ((s.parent = pp) == null)
                        root = s;
                    else if (p == pp.left)
                        pp.left = s;
                    else
                        pp.right = s;
                    if (sr != null)
                        replacement = sr;
                    else
                        replacement = p;
                }
                else if (pl != null)
                    replacement = pl;
                else if (pr != null)
                    replacement = pr;
                else
                    replacement = p;
                if (replacement != p) {
                    TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;
                    if (pp == null)
                        root = replacement;
                    else if (p == pp.left)
                        pp.left = replacement;
                    else
                        pp.right = replacement;
                    p.left = p.right = p.parent = null;
                }

                TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);

                if (replacement == p) {  // detach
                    TreeNode&lt;K,V&gt; pp = p.parent;
                    p.parent = null;
                    if (pp != null) {
                        if (p == pp.left)
                            pp.left = null;
                        else if (p == pp.right)
                            pp.right = null;
                    }
                }
                if (movable)
                    moveRootToFront(tab, r);
            }

            /**
             * Splits nodes in a tree bin into lower and upper tree bins,
             * or untreeifies if now too small. Called only from resize;
             * see above discussion about split bits and indices.
             *
             * @param map the map
             * @param tab the table for recording bin heads
             * @param index the index of the table being split
             * @param bit the bit of hash to split on
             */
            final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) {
                TreeNode&lt;K,V&gt; b = this;
                // Relink into lo and hi lists, preserving order
                TreeNode&lt;K,V&gt; loHead = null, loTail = null;
                TreeNode&lt;K,V&gt; hiHead = null, hiTail = null;
                int lc = 0, hc = 0;
                for (TreeNode&lt;K,V&gt; e = b, next; e != null; e = next) {
                    next = (TreeNode&lt;K,V&gt;)e.next;
                    e.next = null;
                    if ((e.hash &amp; bit) == 0) {
                        if ((e.prev = loTail) == null)
                            loHead = e;
                        else
                            loTail.next = e;
                        loTail = e;
                        ++lc;
                    }
                    else {
                        if ((e.prev = hiTail) == null)
                            hiHead = e;
                        else
                            hiTail.next = e;
                        hiTail = e;
                        ++hc;
                    }
                }

                if (loHead != null) {
                    if (lc &lt;= UNTREEIFY_THRESHOLD)
                        tab[index] = loHead.untreeify(map);
                    else {
                        tab[index] = loHead;
                        if (hiHead != null) // (else is already treeified)
                            loHead.treeify(tab);
                    }
                }
                if (hiHead != null) {
                    if (hc &lt;= UNTREEIFY_THRESHOLD)
                        tab[index + bit] = hiHead.untreeify(map);
                    else {
                        tab[index + bit] = hiHead;
                        if (loHead != null)
                            hiHead.treeify(tab);
                    }
                }
            }

            /* ------------------------------------------------------------ */
            // Red-black tree methods, all adapted from CLR

            static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root,
                                                  TreeNode&lt;K,V&gt; p) {
                TreeNode&lt;K,V&gt; r, pp, rl;
                if (p != null &amp;&amp; (r = p.right) != null) {
                    if ((rl = p.right = r.left) != null)
                        rl.parent = p;
                    if ((pp = r.parent = p.parent) == null)
                        (root = r).red = false;
                    else if (pp.left == p)
                        pp.left = r;
                    else
                        pp.right = r;
                    r.left = p;
                    p.parent = r;
                }
                return root;
            }

            static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root,
                                                   TreeNode&lt;K,V&gt; p) {
                TreeNode&lt;K,V&gt; l, pp, lr;
                if (p != null &amp;&amp; (l = p.left) != null) {
                    if ((lr = p.left = l.right) != null)
                        lr.parent = p;
                    if ((pp = l.parent = p.parent) == null)
                        (root = l).red = false;
                    else if (pp.right == p)
                        pp.right = l;
                    else
                        pp.left = l;
                    l.right = p;
                    p.parent = l;
                }
                return root;
            }

            static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root,
                                                        TreeNode&lt;K,V&gt; x) {
                x.red = true;
                for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) {
                    if ((xp = x.parent) == null) {
                        x.red = false;
                        return x;
                    }
                    else if (!xp.red || (xpp = xp.parent) == null)
                        return root;
                    if (xp == (xppl = xpp.left)) {
                        if ((xppr = xpp.right) != null &amp;&amp; xppr.red) {
                            xppr.red = false;
                            xp.red = false;
                            xpp.red = true;
                            x = xpp;
                        }
                        else {
                            if (x == xp.right) {
                                root = rotateLeft(root, x = xp);
                                xpp = (xp = x.parent) == null ? null : xp.parent;
                            }
                            if (xp != null) {
                                xp.red = false;
                                if (xpp != null) {
                                    xpp.red = true;
                                    root = rotateRight(root, xpp);
                                }
                            }
                        }
                    }
                    else {
                        if (xppl != null &amp;&amp; xppl.red) {
                            xppl.red = false;
                            xp.red = false;
                            xpp.red = true;
                            x = xpp;
                        }
                        else {
                            if (x == xp.left) {
                                root = rotateRight(root, x = xp);
                                xpp = (xp = x.parent) == null ? null : xp.parent;
                            }
                            if (xp != null) {
                                xp.red = false;
                                if (xpp != null) {
                                    xpp.red = true;
                                    root = rotateLeft(root, xpp);
                                }
                            }
                        }
                    }
                }
            }

            static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root,
                                                       TreeNode&lt;K,V&gt; x) {
                for (TreeNode&lt;K,V&gt; xp, xpl, xpr;;)  {
                    if (x == null || x == root)
                        return root;
                    else if ((xp = x.parent) == null) {
                        x.red = false;
                        return x;
                    }
                    else if (x.red) {
                        x.red = false;
                        return root;
                    }
                    else if ((xpl = xp.left) == x) {
                        if ((xpr = xp.right) != null &amp;&amp; xpr.red) {
                            xpr.red = false;
                            xp.red = true;
                            root = rotateLeft(root, xp);
                            xpr = (xp = x.parent) == null ? null : xp.right;
                        }
                        if (xpr == null)
                            x = xp;
                        else {
                            TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;
                            if ((sr == null || !sr.red) &amp;&amp;
                                (sl == null || !sl.red)) {
                                xpr.red = true;
                                x = xp;
                            }
                            else {
                                if (sr == null || !sr.red) {
                                    if (sl != null)
                                        sl.red = false;
                                    xpr.red = true;
                                    root = rotateRight(root, xpr);
                                    xpr = (xp = x.parent) == null ?
                                        null : xp.right;
                                }
                                if (xpr != null) {
                                    xpr.red = (xp == null) ? false : xp.red;
                                    if ((sr = xpr.right) != null)
                                        sr.red = false;
                                }
                                if (xp != null) {
                                    xp.red = false;
                                    root = rotateLeft(root, xp);
                                }
                                x = root;
                            }
                        }
                    }
                    else { // symmetric
                        if (xpl != null &amp;&amp; xpl.red) {
                            xpl.red = false;
                            xp.red = true;
                            root = rotateRight(root, xp);
                            xpl = (xp = x.parent) == null ? null : xp.left;
                        }
                        if (xpl == null)
                            x = xp;
                        else {
                            TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;
                            if ((sl == null || !sl.red) &amp;&amp;
                                (sr == null || !sr.red)) {
                                xpl.red = true;
                                x = xp;
                            }
                            else {
                                if (sl == null || !sl.red) {
                                    if (sr != null)
                                        sr.red = false;
                                    xpl.red = true;
                                    root = rotateLeft(root, xpl);
                                    xpl = (xp = x.parent) == null ?
                                        null : xp.left;
                                }
                                if (xpl != null) {
                                    xpl.red = (xp == null) ? false : xp.red;
                                    if ((sl = xpl.left) != null)
                                        sl.red = false;
                                }
                                if (xp != null) {
                                    xp.red = false;
                                    root = rotateRight(root, xp);
                                }
                                x = root;
                            }
                        }
                    }
                }
            }

            /**
             * Recursive invariant check
             */
            static &lt;K,V&gt; boolean checkInvariants(TreeNode&lt;K,V&gt; t) {
                TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right,
                    tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next;
                if (tb != null &amp;&amp; tb.next != t)
                    return false;
                if (tn != null &amp;&amp; tn.prev != t)
                    return false;
                if (tp != null &amp;&amp; t != tp.left &amp;&amp; t != tp.right)
                    return false;
                if (tl != null &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))
                    return false;
                if (tr != null &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))
                    return false;
                if (t.red &amp;&amp; tl != null &amp;&amp; tl.red &amp;&amp; tr != null &amp;&amp; tr.red)
                    return false;
                if (tl != null &amp;&amp; !checkInvariants(tl))
                    return false;
                if (tr != null &amp;&amp; !checkInvariants(tr))
                    return false;
                return true;
            }
        }
</code></pre>
                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"HashMap","level":"1.2.1.1.1","depth":4,"next":{"title":"java.util.concurrent","level":"1.2.1.2","depth":3,"ref":"","articles":[{"title":"CountDownLatch","level":"1.2.1.2.1","depth":4,"path":"code_read/javautilconcurrent/CountDownLatch.md","ref":"code_read/javautilconcurrent/CountDownLatch.md","articles":[]},{"title":"CyclicBarrier","level":"1.2.1.2.2","depth":4,"path":"code_read/javautilconcurrent/CyclicBarrier.md","ref":"code_read/javautilconcurrent/CyclicBarrier.md","articles":[]}]},"previous":{"title":"java.util","level":"1.2.1.1","depth":3,"ref":"","articles":[{"title":"HashMap","level":"1.2.1.1.1","depth":4,"path":"code_read/javautil/HashMap.md","ref":"code_read/javautil/HashMap.md","articles":[]}]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":["livereload"],"pluginsConfig":{"livereload":{},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"code_read/javautil/HashMap.md","mtime":"2018-03-05T11:20:38.081Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2018-03-15T12:15:54.190Z"},"basePath":"../..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-livereload/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

